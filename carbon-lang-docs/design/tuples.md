# 元组

## 目录

- [待办事项](#todo)
- 概述
  - [空元组](#empty-tuples)
  - [索引作为编译时常量](#indices-as-compile-time-constants)
  - [现场执行的操作](#operations-performed-field-wise)
- 开放性问题
  - [切片范围](#slicing-ranges)
  - [单值元组](#single-value-tuples)
  - [函数模式匹配](#function-pattern-match)
  - [类型与类型的元组](#type-vs-tuple-of-types)

## 待办事项

这是一个骨架设计，添加以支持[概述](README.md)。它不应该被视为被核心团队所接受;相反，它是一个占位符，直到我们有更多的时间来检查这个细节。欢迎酌情重写和更新。

## 概述

主要复合类型涉及将其他类型的简单聚合为元组（在形式类型理论中称为“产品类型”）：

```
fn DoubleBoth(x: i32, y: i32) -> (i32, i32) {
  return (2 * x, 2 * y);
}
```

此函数返回由类型 表示的两个整数的元组。要返回它的表达式使用特殊的元组语法在表达式中构建元组：。在这两种情况下，这实际上是相同的语法。返回类型是元组表达式，第一个和第二个元素是引用该类型的表达式。唯一的区别是这些表达式的类型。两者都是元组，但一个是类型的元组。`(i32, i32)``(<expression>, <expression>)``i32`

元素访问使用下标语法：

```
fn Bar(x: i32, y: i32) -> i32 {
  var t: (i32, i32) = (x, y);
  return t[0] + t[1];
}
```

元组还支持多个索引和切片来重构元组元素：

```
fn Baz(x: i32, y: i32, z: i32) -> (i32, i32) {
  var t1: (i32, i32, i32) = (x, y, z);
  var t2: (i32, i32, i32) = t1[(2, 1, 0)];
  return t2[0 .. 2];
}
```

此代码首先反转元组，然后使用半开索引范围提取切片。

### 空元组

`()`是空元组。这用于设计的其他部分，例如[函数](functions.md)。

### 索引作为编译时常量

在这个例子中，我们可能希望将这些索引限制为编译时常量。否则，运行时索引将需要突然切换到变体样式的返回类型来处理异构元组。这既令人惊讶又复杂，价值很小或根本没有价值。`t1[(2, 1, 0)]`

### 现场执行的操作

与其他一些聚合数据类型（如[结构类型](classes.md#struct-types)）一样，在字段方面为元组定义了一些操作：

- 初始化
- 分配
- 平等与不平等比较
- 有序比较
- 参数传递的隐式转换
- 破坏

对于二进制操作，两个元组必须具有相同数量的组件，并且必须为两个元组的相应组件类型定义操作。

**引用：**参数传递的赋值、比较和隐式转换的规则在[问题线索问题 #710](https://github.com/carbon-language/carbon-lang/issues/710) 中确定。

## 开放性问题

### 切片范围

的意图是作为基于半开范围 [0， 2] 形成索引序列的语法。我们需要在这里回答一堆问题：`0 .. 2`

- 这在任何地方都有效吗？只有一些地方？

- 顺序*是什么*？

  - 如果它是索引的元组，也许这可以解决上述问题，并且与使用多个索引的函数调用索引不同于使用索引元组的索引。

- 我们是否需要闭合范围的语法（也许，不清楚它是否最终*对齐*或与模式匹配的其他可能用途*冲突*）？`...``...`

- 所有这些语法也都非常接近，语法的相似性好吗？

  ```
  0.2
  ```

  - 我们是否要要求被空格包围以最大程度地减少这种碰撞？`..`

### 单值元组

这仍然是一个积极调查的领域。这里的所有方法都存在严重问题。如果没有将一元组折叠为标量，我们需要区分带括号的表达式（）和一元组（在Python或Rust中），如果我们区分它们，那么我们就不能将函数调用建模为简单的函数名称，后跟一个参数元组;其中之一并成为特例。通过折叠，我们要么通过禁止工作来破坏通用性，要么不清楚从括号中的表达式访问嵌套元组的第一个元素意味着什么：。`(42)``(42,)``f(0)``f(0,)``(42)[0]``((1, 2))[0]`

### 函数模式匹配

我们需要扩展一些有趣的角落案例，以完全更准确地讨论函数调用的确切语义模型及其模式匹配，特别是处理可变参数模式和元组的转发作为参数。我们希望这里有一个纯类型系统的答案，而不需要模板直接参与类型系统之外，就像C++变量中发生的那样。

### 类型与类型的元组

是类型，类型元组，还是两者之间有区别？这些情况是否需要不同的语法？`(i32, i32)`