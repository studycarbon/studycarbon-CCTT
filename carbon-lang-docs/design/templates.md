# 模板

## 目录

- [待办事项](#todo)
- 概述
  - [具有模板参数的类型](#types-with-template-parameters)
  - [具有模板参数的函数](#functions-with-template-parameters)
  - [超载](#overloading)
  - [使用接口约束模板](#constraining-templates-with-interfaces)

## 待办事项

这是一个骨架设计，添加以支持[概述](README.md)。它不应该被视为被核心团队所接受;相反，它是一个占位符，直到我们有更多的时间来检查这个细节。欢迎酌情重写和更新。

## 概述

碳模板遵循与C++模板相同的基本范式：它们被实例化，导致后期类型检查，鸭子类型和延迟绑定。它们都实现了Carbon和C++之间的互操作性，并解决了一些（希望是有限的）用例，在这些用例中，泛型强加的类型检查严格性没有帮助。

### 具有模板参数的类型

参数化用户定义类型时，可以将参数标记为模板参数。生成的 type-function 将使用提供的参数实例化参数化定义，以便在使用时生成完整的类型。请注意，只有标记为具有此模板行为的参数才会受到完全实例化的影响 -- 其他参数将进行类型检查，并尽可能提前绑定。例如：

```
class Stack(template T:! Type) {
  var storage: Array(T);

  fn Push[addr me: Self*](value: T);
  fn Pop[addr me: Self*]() -> T;
}
```

这既定义了参数化类型 （），又使用了一个 （）。在类型的定义中，模板类型参数可以在使用普通类型的所有位置使用，并且只能通过实例化时检查的类型来使用。`Stack``Array``T`

### 具有模板参数的函数

Carbon中推导和显式函数参数都可以标记为模板参数。调用这些参数时，这些参数的参数会触发函数定义的实例化，在替换提供的（或计算的，如果推导的）参数后，完全类型检查并解析该定义。然后，运行时调用将剩余的参数传递给生成的完整定义。

```
fn Convert[template T:! Type](source: T, template U:! Type) -> U {
  var converted: U = source;
  return converted;
}

fn Foo(i: i32) -> f32 {
  // Instantiates with the `T` deduced argument set to `i32` and the `U`
  // explicit argument set to `f32`, then calls with the runtime value `i`.
  return Convert(i, f32);
}
```

在这里，我们推导出一个类型参数并显式传递另一个类型参数。无法显式传递推导的类型参数，而是调用站点应强制转换或转换参数以控制演绎。显式类型在运行时参数之后传递。虽然这使得该类型对*该*运行时参数的声明不可用，但它仍然是一个模板参数，即使在函数声明的其余部分中也可以用作类型。

### 超载

C++模板的一个重要功能是能够自定义它们最终如何专用于特定类型。由于模板参数（无论是作为类型参数还是函数参数）都是模式匹配的，因此我们希望利用模式匹配技术来提供“更好地匹配”定义，这些定义类似于C++模板中的特化。当通过模式匹配表示时，这可能使不仅仅是模板参数特化，但这是我们想要谨慎探索的领域。

### 使用接口约束模板

由于我们只考虑将特定*参数*模板化，并且可以使用[泛型系统](README.md#generics)将它们单独迁移到受约束的界面，因此约束模板本身可能不那么重要。相反，我们期望参数化类型和函数可以根据它们的约束位置混合使用泛型参数和模板化参数。

但是，如果仍有用例，我们希望探索将泛型系统的接口约束直接应用于模板参数，而不是创建新的约束系统。